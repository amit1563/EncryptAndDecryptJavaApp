package com.encryption.test;

import static org.junit.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.nio.file.Paths;

import javax.xml.bind.JAXBException;

import org.junit.Test;
import org.junit.internal.runners.JUnit4ClassRunner;
import org.junit.runner.RunWith;

import com.encryption.util.EncryptionKeyUtils;
import com.encryption.util.FileOperationUtils;
import com.encryption.util.KeyStoreManager;
import com.encryption.xml.JAXBExample;
import com.encryption.xml.User;

@RunWith(JUnit4ClassRunner.class)
public class EncryptWithOpensslDecryptWithJKS {
	private static final String workingKeyDirectoryForJks = System.getProperty("user.dir");

	@Test
	public void testEndToEnd() throws Exception {
		File keyDirectoryForJks = new File(workingKeyDirectoryForJks);
		assertTrue(keyDirectoryForJks.exists());
		KeyStoreManager keyStoreManager = new KeyStoreManager();

		/*
		 * make sure that public key exist in der (generated by java keygen tool) format
		 * at the default location
		 */

		File publicKeyFromStore = new File(keyDirectoryForJks, EncryptionKeyUtils.PUBLIC_KEY_FROM_KEYSTORE);
		assertTrue(publicKeyFromStore.exists());
		convertPublicKeyToPemOpenSSlFormat(publicKeyFromStore);

		// test ends here for format of the key file.

		/*
		 * Here we will try to encrypt the data with the help of retrieved public key
		 * from the client side for testing will try to fetch from where it is already
		 * saved after retrieval i.e local location
		 * 
		 */

		String testTextStringInJksDirWithClientPublicKey = "Text To Encrypt with client key";
		File textToEncryptInJksDirWithClientPublicKey = new File(keyDirectoryForJks,
				"text_to_encrypt_with_Client_Key.txt");
		FileOperationUtils.writeBytesToFile(textToEncryptInJksDirWithClientPublicKey,
				testTextStringInJksDirWithClientPublicKey.getBytes());

		// Encrypt with the help of openssl command by passing file which need to be
		// encrypted
		// and public key (Client side generated by the keystore manager and converted
		// in pem format using openssl cli )
		// Basically here we are again reading the file already converted by openssl in
		// pem because we are going to grab it any way from remote database
		File publicKeyFileInPemFormat = new File(keyDirectoryForJks, EncryptionKeyUtils.PUBLIC_KEY_PEM_FORMAT);
		File publicKeyRetrivedfromClientSideInPemFormat = new File(keyDirectoryForJks,
				EncryptionKeyUtils.PUBLIC_KEY_RETRIVED_FROM_CLIENTSIDE_PEM_FORMAT);
		FileOperationUtils.writeBytesToFile(publicKeyRetrivedfromClientSideInPemFormat,
				Files.readAllBytes(Paths.get(publicKeyFileInPemFormat.getAbsolutePath())));

		// here we are passing the instance of file created by reading original pem file
		// created by openssl.
		encryptTextFileWithOpenssl(publicKeyRetrivedfromClientSideInPemFormat,
				textToEncryptInJksDirWithClientPublicKey);

		// create xml with encrypted parameter
		File encryptedFile = new File(keyDirectoryForJks, EncryptionKeyUtils.ENCRYPTED_FILE_NAME);

		// convert it to the Base64 with openssl cli ==>
		convertToBes64Format(encryptedFile);
		File encryptedFileWithBes64 = new File(keyDirectoryForJks, "Bes64Data");

		// here we are trying to create a xml file with the required data to be
		// encrypted in bes64 format converted by the openssl cli
		createXmlFileWithEncryptedParameter(encryptedFileWithBes64);

		// end of encryption with the help of publicKey Retrieved from ClientSide

		// decrypt java side
		// we are expecting a xml file will have data in encrypted form as xml element
		String encodedStringParam = JAXBExample.readFromXml();
		File encodedvalueInBas64Format = new File(keyDirectoryForJks, "encodedvalueInBas64Format");
		FileOperationUtils.writeBytesToFile(encodedvalueInBas64Format, encodedStringParam.getBytes());
		// encodedStringParam will be in bes64 openssl format will try to read it and
		// convert again to default format with cli
		convertToDefaultFormat(encodedvalueInBas64Format);

		byte[] encryptedText = FileOperationUtils
				.readFile(new FileInputStream(new File(keyDirectoryForJks, "defaultFormat")));
		byte[] decryptedText = keyStoreManager.decryptBytes(encryptedText, "password");
		File fileToWriteDecryptedText = new File(keyDirectoryForJks, "decrypted.txt");
		FileOperationUtils.writeBytesToFile(fileToWriteDecryptedText, decryptedText);

	}

	/**
	 * @param publicKey
	 * @param textToEncryptFile
	 * @return
	 * @throws Exception
	 */
	private String encryptTextFileWithOpenssl(File publicKey, File textToEncryptFile) throws Exception {

		String publicKeyPath = publicKey.getAbsolutePath();
		String encryptedFile = publicKey.getParent() + "\\encrypted.txt";
		String commandLine = ".\\src\\tools\\openssl\\bin\\openssl.exe rsautl -encrypt -pubin -in ";
		commandLine += ("\"" + textToEncryptFile + "\"");
		commandLine += " -inkey ";
		commandLine += ("\"" + publicKeyPath + "\"");
		commandLine += " -out ";
		commandLine += publicKey.getParent() + File.separator + EncryptionKeyUtils.ENCRYPTED_FILE_NAME;
		runProcess(commandLine);
		return encryptedFile;
	}

	/**
	 * Run the process and capture the output
	 * 
	 * @param commandLine
	 * @throws IOException
	 */
	private String runProcess(String commandLine) throws IOException {
		Process proc = Runtime.getRuntime().exec(commandLine);
		BufferedReader in = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
		StringBuffer sb = new StringBuffer();
		String response;
		while ((response = in.readLine()) != null) {
			sb.append(response);
		}
		return sb.toString();
	}

	/**
	 * Java creates a key in DER format, this needs to be converted to PEM format to
	 * be used by openssl libs need to call this conversion : openssl rsa -pubin
	 * -inform der < public_key.der > public_key.pem
	 * 
	 * @param publicKey
	 */
	private void convertPublicKeyToPemOpenSSlFormat(File publicKey) throws Exception {
		String publicKeyPath = publicKey.getAbsolutePath();
		String commandLine = ".\\src\\tools\\openssl\\bin\\openssl.exe rsa -pubin -inform der -in ";
		commandLine += ("\"" + publicKeyPath + "\"");
		commandLine += " -out ";
		commandLine += publicKey.getParent() + File.separator + EncryptionKeyUtils.PUBLIC_KEY_PEM_FORMAT;
		runProcess(commandLine);
	}

	public void createXmlFileWithEncryptedParameter(File encryptedFile)
			throws FileNotFoundException, IOException, JAXBException {
		String bytes = new String(Files.readAllBytes(Paths.get(encryptedFile.getAbsolutePath())));
		User user = new User();
		user.setPassword(bytes);
		JAXBExample.writeXml(user);
	}

	private void convertToBes64Format(File fileToConvertToBes64) throws Exception {
		String commandLine = ".\\src\\tools\\openssl\\bin\\openssl.exe base64 -e -in ";
		commandLine += ("\"" + fileToConvertToBes64 + "\"");
		commandLine += " -out ";
		commandLine += fileToConvertToBes64.getParent() + File.separator + "Bes64Data";
		runProcess(commandLine);
	}

	private void convertToDefaultFormat(File fileToConvertToDefaultFormat) throws Exception {

		String commandLine2 = ".\\src\\tools\\openssl\\bin\\openssl.exe base64 -d -in ";
		commandLine2 += ("\"" + fileToConvertToDefaultFormat + "\"");
		commandLine2 += " -out ";
		commandLine2 += fileToConvertToDefaultFormat.getParent() + File.separator + "defaultFormat";
		runProcess(commandLine2);
	}
}
